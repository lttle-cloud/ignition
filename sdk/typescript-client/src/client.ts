// Generated by Damascus
// Do not edit this file directly

export interface VolumeV1 {
  tags?: string[];
  namespace?: string;
  name: string;
  mode: VolumeMode;
  size: string;
}


export type VolumeMode =
  "read-only" |
  "writeable";


export interface VolumeStatus {
  hash: number;
  volumeId?: string;
  sizeBytes: number;
}


export type Volume =
  { "volume.v1": VolumeV1 };


export interface QueryParams {
  query: string;
  env: { [key: string]: string };
  var: { [key: string]: any };
  git?: QueryGitInfo;
  lttleProfile: string;
}


export interface QueryGitInfo {
  branch?: string;
  commitSha: string;
  commitMessage: string;
  tag?: string;
  latestTag?: string;
  ref: string;
}


export interface QueryResponse {
  queryResult: any;
}


export interface ListNamespaces {
  namespaces: Namespace[];
}


export interface Namespace {
  name: string;
  createdAt: number;
}


export interface DeleteNamespaceParams {
  namespace: string;
  confirm: boolean;
}


export interface DeleteNamespaceResponse {
  resources: DeletedResource[];
  didDelete: boolean;
}


export interface DeletedResource {
  kind: string;
  name: string;
}


export interface CertificateV1 {
  tags?: string[];
  namespace?: string;
  name: string;
  domains: string[];
  issuer: CertificateIssuer;
}


export type CertificateIssuer =
  { auto: { provider: string, email?: string, renewal?: CertificateRenewalConfig } } |
  { manual: { certPath: string, keyPath: string, caPath?: string } };


export interface CertificateRenewalConfig {
  daysBeforeExpiry?: number;
  retryIntervalHours?: number;
}


export interface CertificateStatus {
  state: CertificateState;
  notBefore?: string;
  notAfter?: string;
  lastFailureReason?: string;
  renewalTime?: string;
  domains: string[];
  autoProviderName?: string;
}


export type CertificateState =
  "pending" |
  "pending-acme-account" |
  "pending-dns-resolution" |
  "ready" |
  "renewing" |
  "failed" |
  "expired" |
  "revoked" |
  { pendingOrder?: string } |
  { pendingChallenge: string } |
  { validating: string } |
  { issuing: string };


export type Certificate =
  { "certificate.v1": CertificateV1 };


export interface AppV1 {
  tags?: string[];
  namespace?: string;
  name: string;
  image?: string;
  build?: MachineBuild;
  resources: MachineResources;
  restartPolicy?: MachineRestartPolicy;
  mode?: MachineMode;
  volumes?: MachineVolumeBinding[];
  command?: string[];
  environment?: { [key: string]: string };
  dependsOn?: MachineDependency[];
  expose?: { [key: string]: AppExpose };
}


export type MachineBuild =
  "auto" |
  { options: MachineBuildOptions } |
  { docker: MachineDockerOptions };


export interface MachineBuildOptions {
  name?: string;
  tag?: string;
  image?: string;
  dir?: string;
}


export interface MachineDockerOptions {
  name?: string;
  tag?: string;
  image?: string;
  context?: string;
  dockerfile?: string;
  args?: { [key: string]: string };
}


export interface MachineResources {
  cpu: number;
  memory: number;
}


export type MachineRestartPolicy =
  "never" |
  "always" |
  "on-failure" |
  "remove";


export type MachineMode =
  "regular" |
  { flash: { strategy: MachineSnapshotStrategy, timeout?: number } };


export type MachineSnapshotStrategy =
  "first-listen" |
  "user-space-ready" |
  "manual" |
  { nthListen: number } |
  { listenOnPort: number };


export interface MachineVolumeBinding {
  name: string;
  namespace?: string;
  path: string;
}


export interface MachineDependency {
  name: string;
  namespace?: string;
}


export interface AppExpose {
  port: number;
  connectionTracking?: ServiceTargetConnectionTracking;
  external?: AppExposeExternal;
  internal?: AppExposeInternal;
}


export type ServiceTargetConnectionTracking =
  "connection-aware" |
  { "traffic-aware": { inactivityTimeout?: number } };


export interface AppExposeExternal {
  host?: string;
  port?: number;
  protocol: ServiceBindExternalProtocol;
}


export type ServiceBindExternalProtocol =
  "http" |
  "https" |
  "tls";


export interface AppExposeInternal {
  port?: number;
}


export interface AppStatus {
  machineHash: number;
  machineName?: string;
  allocatedServices: { [key: string]: AppAllocatedService };
}


export interface AppAllocatedService {
  name: string;
  hash: number;
  domain?: string;
}


export type App =
  { "app.v1": AppV1 };


export interface Me {
  tenant: string;
  sub: string;
}


export interface RegistryRobot {
  registry: string;
  user: string;
  pass: string;
}


export interface AllocatedBuilder {
  host: string;
  clientCertPem: string;
  clientKeyPem: string;
  caCertPem: string;
}


export interface GadgetInitRunParams {
  discoveryData: GadgetInitDiscoveryData;
  reasoningEffort?: GadgetInitReasoningEffort;
  messages: GadgetClientMessage[];
}


export interface GadgetInitDiscoveryData {
  baseDirName: string;
  baseDirBuildPlan: DirBuildPlan;
}


export interface DirBuildPlan {
  detectedProviders: string[];
  phases: BuildPlanPhase[];
}


export interface BuildPlanPhase {
  name: string;
  buildInfo: string;
}


export type GadgetInitReasoningEffort =
  "Minimal" |
  "Low" |
  "Medium" |
  "High";


export interface GadgetClientMessage {
  serviceMessage: GadgetServiceMessage;
  clientReply?: GadgetClientReply;
}


export type GadgetServiceMessage =
  { ReadFile: ReadFileArgs } |
  { ListDir: ListDirArgs } |
  { DirBuildPlan: DirBuildPlanArgs } |
  { Finish: GadgetInitData } |
  { error: string };


export interface ReadFileArgs {
  path: string;
}


export interface ListDirArgs {
  path: string;
  maxDepth?: number;
}


export interface DirBuildPlanArgs {
  path: string;
}


export interface GadgetInitData {
  plan: InitPlan;
}


export interface InitPlan {
  apps: InitApp[];
  volumes: InitVolume[];
  issues: InitIssue[];
  warnings: InitWarning[];
}


export interface InitApp {
  name: string;
  namespace?: string;
  source: InitAppSource;
  snapshotStrategy?: InitAppSnapshotStrategy;
  envs?: InitAppEnv[];
  dependsOn?: InitAppDependsOn[];
  exposedPorts?: InitAppExposedPort[];
  bindedVolumes?: InitAppBindedVolume[];
}


export type InitAppSource =
  { BuildAutomatically: InitAppBuildAuto } |
  { BuildWithDockerfile: InitAppBuildDockerfile } |
  { Image: InitAppImage };


export interface InitAppBuildAuto {
  dirPath?: string;
  appendDockerIgnoreExtra?: InitAppendDockerIgnoreExtra;
}


export interface InitAppendDockerIgnoreExtra {
  path: string;
  lines: string[];
}


export interface InitAppBuildDockerfile {
  dirPath: string;
  dockerfileName?: string;
  appendDockerIgnoreExtra?: InitAppendDockerIgnoreExtra;
}


export interface InitAppImage {
  image: string;
}


export type InitAppSnapshotStrategy =
  "SuspendBeforeStart" |
  "SuspendAfterListenOnAnyPort" |
  "SuspendManually" |
  { suspendafterlistenonport: number };


export interface InitAppEnv {
  name: string;
  value: InitAppEnvValue;
}


export type InitAppEnvValue =
  { literal: string } |
  { expression: string } |
  { CopyFromEnvFile: { varName: string } };


export interface InitAppDependsOn {
  name: string;
  namespace?: string;
}


export interface InitAppExposedPort {
  name: string;
  port: number;
  mode: InitAppExposedPortMode;
}


export type InitAppExposedPortMode =
  { Internal: InitAppExposedPortProtocolInternal } |
  { External: InitAppExposedPortProtocolExternal };


export type InitAppExposedPortProtocolInternal =
  "Tcp";


export type InitAppExposedPortProtocolExternal =
  "Tls" |
  "Https";


export interface InitAppBindedVolume {
  name: string;
  namespace?: string;
  path: string;
}


export interface InitVolume {
  name: string;
  namespace?: string;
}


export interface InitIssue {
  message: string;
}


export interface InitWarning {
  message: string;
}


export type GadgetClientReply =
  { ReadFile: ReadFileResult } |
  { ListDir: ListDirResult } |
  { DirBuildPlan: DirBuildPlan } |
  { error: string };


export interface ReadFileResult {
  path: string;
  content: string;
}


export interface ListDirResult {
  items: ListDirItem[];
}


export interface ListDirItem {
  path: string;
  isDir: boolean;
  size: number;
}


export interface GadgetInitRunResponse {
  messages: GadgetServiceMessage[];
}


export type LogStreamParams =
  { machine_name: { machineName: string, startTsNs?: string, endTsNs?: string } } |
  { group_name: { groupName: string, startTsNs?: string, endTsNs?: string } };


export interface LogStreamItem {
  timestamp: number;
  message: string;
  targetStream: LogStreamTarget;
}


export type LogStreamTarget =
  "stdout" |
  "stderr";


export interface ExecParams {
  machineName: string;
  command: string;
  stdin?: boolean;
  tty?: boolean;
}


export interface MachineV1 {
  tags?: string[];
  namespace?: string;
  name: string;
  image?: string;
  build?: MachineBuild;
  resources: MachineResources;
  restartPolicy?: MachineRestartPolicy;
  mode?: MachineMode;
  volumes?: MachineVolumeBinding[];
  command?: string[];
  environment?: { [key: string]: string };
  dependsOn?: MachineDependency[];
}


export interface MachineStatus {
  hash: number;
  phase: MachinePhase;
  imageId?: string;
  imageResolvedReference?: string;
  machineId?: string;
  machineIp?: string;
  machineTap?: string;
  machineImageVolumeId?: string;
  lastBootTimeUs?: number;
  firstBootTimeUs?: number;
  lastRestartingTimeUs?: number;
  lastExitCode?: number;
}


export type MachinePhase =
  "idle" |
  "pulling-image" |
  "waiting" |
  "creating" |
  "booting" |
  "ready" |
  "suspending" |
  "suspended" |
  "stopping" |
  "stopped" |
  "restarting" |
  { error: { message: string } };


export type Machine =
  { "machine.v1": MachineV1 };


export interface ServiceV1 {
  tags?: string[];
  namespace?: string;
  name: string;
  target: ServiceTarget;
  bind: ServiceBind;
}


export interface ServiceTarget {
  name: string;
  namespace?: string;
  port: number;
  protocol: ServiceTargetProtocol;
  connectionTracking?: ServiceTargetConnectionTracking;
}


export type ServiceTargetProtocol =
  "http" |
  "tcp";


export type ServiceBind =
  { internal: { port?: number } } |
  { external: { host: string, port?: number, protocol: ServiceBindExternalProtocol } };


export interface ServiceStatus {
  serviceIp?: string;
  internalDnsHostname?: string;
}


export type Service =
  { "service.v1": ServiceV1 };


export class WebSocketStream<T> {
  private ws: WebSocket | null = null;
  private messageHandlers: Set<(data: T) => void> = new Set();
  private errorHandlers: Set<(error: Error) => void> = new Set();
  private closeHandlers: Set<() => void> = new Set();

  constructor(
    private url: string,
    private deserialize: (data: any) => T,
    private headers: Record<string, string> | undefined,
    private WebSocketImpl: typeof WebSocket
  ) {}

  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      const wsUrl = this.url.replace(/^http/, 'ws');
      this.ws = new this.WebSocketImpl(wsUrl);

      this.ws.onopen = () => {
        resolve();
      };

      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          const deserialized = this.deserialize(data);
          this.messageHandlers.forEach(handler => handler(deserialized));
        } catch (error) {
        this.errorHandlers.forEach(handler => handler(error as Error));
        }
      };

      this.ws.onerror = (event) => {
        const error = new Error('WebSocket error');
        this.errorHandlers.forEach(handler => handler(error));
        reject(error);
      };

      this.ws.onclose = () => {
        this.closeHandlers.forEach(handler => handler());
      };
    });
  }

  onMessage(handler: (data: T) => void): () => void {
    this.messageHandlers.add(handler);
    return () => {
      this.messageHandlers.delete(handler);
    };
  }

  onError(handler: (error: Error) => void): () => void {
    this.errorHandlers.add(handler);
    return () => {
      this.errorHandlers.delete(handler);
    };
  }

  onClose(handler: () => void): () => void {
    this.closeHandlers.add(handler);
    return () => {
      this.closeHandlers.delete(handler);
    };
  }

  close(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

export function serializeVolumeV1(value: VolumeV1): any {
  return {
    "tags": value.tags,
    "namespace": value.namespace,
    "name": value.name,
    "mode": serializeVolumeMode(value.mode),
    "size": value.size,
  };
}

export function deserializeVolumeV1(value: any): VolumeV1 {
  return {
    tags: value["tags"],
    namespace: value["namespace"],
    name: value["name"],
    mode: deserializeVolumeMode(value["mode"]),
    size: value["size"],
  };
}

export function serializeVolumeMode(value: VolumeMode): any {
  return value;
}

export function deserializeVolumeMode(value: any): VolumeMode {
  return value;
}

export function serializeVolumeStatus(value: VolumeStatus): any {
  return {
    "hash": value.hash,
    "volume_id": value.volumeId,
    "size_bytes": value.sizeBytes,
  };
}

export function deserializeVolumeStatus(value: any): VolumeStatus {
  return {
    hash: value["hash"],
    volumeId: value["volume_id"],
    sizeBytes: value["size_bytes"],
  };
}

export function serializeVolume(value: Volume): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "volume.v1") {
      result["volume.v1"] = serializeVolumeV1(val as any);
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeVolume(value: any): Volume {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "volume.v1") {
      result["volume.v1"] = deserializeVolumeV1(val as any);
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as Volume;
}

export function serializeQueryParams(value: QueryParams): any {
  return {
    "query": value.query,
    "env": value.env,
    "var": value.var,
    "git": value.git !== undefined ? serializeQueryGitInfo(value.git) : undefined,
    "lttle_profile": value.lttleProfile,
  };
}

export function deserializeQueryParams(value: any): QueryParams {
  return {
    query: value["query"],
    env: value["env"],
    var: value["var"],
    git: value["git"] !== undefined && value["git"] !== null ? deserializeQueryGitInfo(value["git"]) : undefined,
    lttleProfile: value["lttle_profile"],
  };
}

export function serializeQueryGitInfo(value: QueryGitInfo): any {
  return {
    "branch": value.branch,
    "commit_sha": value.commitSha,
    "commit_message": value.commitMessage,
    "tag": value.tag,
    "latest_tag": value.latestTag,
    "ref": value.ref,
  };
}

export function deserializeQueryGitInfo(value: any): QueryGitInfo {
  return {
    branch: value["branch"],
    commitSha: value["commit_sha"],
    commitMessage: value["commit_message"],
    tag: value["tag"],
    latestTag: value["latest_tag"],
    ref: value["ref"],
  };
}

export function serializeQueryResponse(value: QueryResponse): any {
  return {
    "query_result": value.queryResult,
  };
}

export function deserializeQueryResponse(value: any): QueryResponse {
  return {
    queryResult: value["query_result"],
  };
}

export function serializeListNamespaces(value: ListNamespaces): any {
  return {
    "namespaces": value.namespaces.map((x: any) => serializeNamespace(x)),
  };
}

export function deserializeListNamespaces(value: any): ListNamespaces {
  return {
    namespaces: value["namespaces"].map((x: any) => deserializeNamespace(x)),
  };
}

export function serializeNamespace(value: Namespace): any {
  return {
    "name": value.name,
    "created_at": value.createdAt,
  };
}

export function deserializeNamespace(value: any): Namespace {
  return {
    name: value["name"],
    createdAt: value["created_at"],
  };
}

export function serializeDeleteNamespaceParams(value: DeleteNamespaceParams): any {
  return {
    "namespace": value.namespace,
    "confirm": value.confirm,
  };
}

export function deserializeDeleteNamespaceParams(value: any): DeleteNamespaceParams {
  return {
    namespace: value["namespace"],
    confirm: value["confirm"],
  };
}

export function serializeDeleteNamespaceResponse(value: DeleteNamespaceResponse): any {
  return {
    "resources": value.resources.map((x: any) => serializeDeletedResource(x)),
    "did_delete": value.didDelete,
  };
}

export function deserializeDeleteNamespaceResponse(value: any): DeleteNamespaceResponse {
  return {
    resources: value["resources"].map((x: any) => deserializeDeletedResource(x)),
    didDelete: value["did_delete"],
  };
}

export function serializeDeletedResource(value: DeletedResource): any {
  return {
    "kind": value.kind,
    "name": value.name,
  };
}

export function deserializeDeletedResource(value: any): DeletedResource {
  return {
    kind: value["kind"],
    name: value["name"],
  };
}

export function serializeCertificateV1(value: CertificateV1): any {
  return {
    "tags": value.tags,
    "namespace": value.namespace,
    "name": value.name,
    "domains": value.domains,
    "issuer": serializeCertificateIssuer(value.issuer),
  };
}

export function deserializeCertificateV1(value: any): CertificateV1 {
  return {
    tags: value["tags"],
    namespace: value["namespace"],
    name: value["name"],
    domains: value["domains"],
    issuer: deserializeCertificateIssuer(value["issuer"]),
  };
}

export function serializeCertificateIssuer(value: CertificateIssuer): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "auto") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        if (innerKey === "renewal") {
          inner["renewal"] = innerVal as any !== undefined ? serializeCertificateRenewalConfig(innerVal as any) : undefined;
          continue;
        }
        const snakeKey = innerKey.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
        inner[snakeKey] = innerVal;
      }
      result["auto"] = inner;
      continue;
    }
    if (key === "manual") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const snakeKey = innerKey.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
        inner[snakeKey] = innerVal;
      }
      result["manual"] = inner;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeCertificateIssuer(value: any): CertificateIssuer {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "auto") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        if (innerKey === "renewal") {
          inner["renewal"] = innerVal as any !== undefined && innerVal as any !== null ? deserializeCertificateRenewalConfig(innerVal as any) : undefined;
          continue;
        }
        const camelKey = innerKey.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
        inner[camelKey] = innerVal;
      }
      result["auto"] = inner;
      continue;
    }
    if (key === "manual") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const camelKey = innerKey.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
        inner[camelKey] = innerVal;
      }
      result["manual"] = inner;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as CertificateIssuer;
}

export function serializeCertificateRenewalConfig(value: CertificateRenewalConfig): any {
  return {
    "days-before-expiry": value.daysBeforeExpiry,
    "retry-interval-hours": value.retryIntervalHours,
  };
}

export function deserializeCertificateRenewalConfig(value: any): CertificateRenewalConfig {
  return {
    daysBeforeExpiry: value["days-before-expiry"],
    retryIntervalHours: value["retry-interval-hours"],
  };
}

export function serializeCertificateStatus(value: CertificateStatus): any {
  return {
    "state": serializeCertificateState(value.state),
    "not_before": value.notBefore,
    "not_after": value.notAfter,
    "last_failure_reason": value.lastFailureReason,
    "renewal_time": value.renewalTime,
    "domains": value.domains,
    "auto_provider_name": value.autoProviderName,
  };
}

export function deserializeCertificateStatus(value: any): CertificateStatus {
  return {
    state: deserializeCertificateState(value["state"]),
    notBefore: value["not_before"],
    notAfter: value["not_after"],
    lastFailureReason: value["last_failure_reason"],
    renewalTime: value["renewal_time"],
    domains: value["domains"],
    autoProviderName: value["auto_provider_name"],
  };
}

export function serializeCertificateState(value: CertificateState): any {
  // Union serialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "pendingOrder") {
      result["pending-order"] = val;
      continue;
    }
    if (key === "pendingChallenge") {
      result["pending-challenge"] = val;
      continue;
    }
    if (key === "validating") {
      result["validating"] = val;
      continue;
    }
    if (key === "issuing") {
      result["issuing"] = val;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeCertificateState(value: any): CertificateState {
  // Union deserialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value as CertificateState;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "pending-order") {
      result["pendingOrder"] = val;
      continue;
    }
    if (key === "pending-challenge") {
      result["pendingChallenge"] = val;
      continue;
    }
    if (key === "validating") {
      result["validating"] = val;
      continue;
    }
    if (key === "issuing") {
      result["issuing"] = val;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as CertificateState;
}

export function serializeCertificate(value: Certificate): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "certificate.v1") {
      result["certificate.v1"] = serializeCertificateV1(val as any);
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeCertificate(value: any): Certificate {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "certificate.v1") {
      result["certificate.v1"] = deserializeCertificateV1(val as any);
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as Certificate;
}

export function serializeAppV1(value: AppV1): any {
  return {
    "tags": value.tags,
    "namespace": value.namespace,
    "name": value.name,
    "image": value.image,
    "build": value.build !== undefined ? serializeMachineBuild(value.build) : undefined,
    "resources": serializeMachineResources(value.resources),
    "restart-policy": value.restartPolicy !== undefined ? serializeMachineRestartPolicy(value.restartPolicy) : undefined,
    "mode": value.mode !== undefined ? serializeMachineMode(value.mode) : undefined,
    "volumes": value.volumes !== undefined ? value.volumes.map((x: any) => serializeMachineVolumeBinding(x)) : undefined,
    "command": value.command,
    "environment": value.environment,
    "depends-on": value.dependsOn !== undefined ? value.dependsOn.map((x: any) => serializeMachineDependency(x)) : undefined,
    "expose": value.expose,
  };
}

export function deserializeAppV1(value: any): AppV1 {
  return {
    tags: value["tags"],
    namespace: value["namespace"],
    name: value["name"],
    image: value["image"],
    build: value["build"] !== undefined && value["build"] !== null ? deserializeMachineBuild(value["build"]) : undefined,
    resources: deserializeMachineResources(value["resources"]),
    restartPolicy: value["restart-policy"] !== undefined && value["restart-policy"] !== null ? deserializeMachineRestartPolicy(value["restart-policy"]) : undefined,
    mode: value["mode"] !== undefined && value["mode"] !== null ? deserializeMachineMode(value["mode"]) : undefined,
    volumes: value["volumes"] !== undefined && value["volumes"] !== null ? value["volumes"].map((x: any) => deserializeMachineVolumeBinding(x)) : undefined,
    command: value["command"],
    environment: value["environment"],
    dependsOn: value["depends-on"] !== undefined && value["depends-on"] !== null ? value["depends-on"].map((x: any) => deserializeMachineDependency(x)) : undefined,
    expose: value["expose"],
  };
}

export function serializeMachineBuild(value: MachineBuild): any {
  // Union serialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "options") {
      result["options"] = serializeMachineBuildOptions(val as any);
      continue;
    }
    if (key === "docker") {
      result["docker"] = serializeMachineDockerOptions(val as any);
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeMachineBuild(value: any): MachineBuild {
  // Union deserialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value as MachineBuild;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "options") {
      result["options"] = deserializeMachineBuildOptions(val as any);
      continue;
    }
    if (key === "docker") {
      result["docker"] = deserializeMachineDockerOptions(val as any);
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as MachineBuild;
}

export function serializeMachineBuildOptions(value: MachineBuildOptions): any {
  return {
    "name": value.name,
    "tag": value.tag,
    "image": value.image,
    "dir": value.dir,
  };
}

export function deserializeMachineBuildOptions(value: any): MachineBuildOptions {
  return {
    name: value["name"],
    tag: value["tag"],
    image: value["image"],
    dir: value["dir"],
  };
}

export function serializeMachineDockerOptions(value: MachineDockerOptions): any {
  return {
    "name": value.name,
    "tag": value.tag,
    "image": value.image,
    "context": value.context,
    "dockerfile": value.dockerfile,
    "args": value.args,
  };
}

export function deserializeMachineDockerOptions(value: any): MachineDockerOptions {
  return {
    name: value["name"],
    tag: value["tag"],
    image: value["image"],
    context: value["context"],
    dockerfile: value["dockerfile"],
    args: value["args"],
  };
}

export function serializeMachineResources(value: MachineResources): any {
  return {
    "cpu": value.cpu,
    "memory": value.memory,
  };
}

export function deserializeMachineResources(value: any): MachineResources {
  return {
    cpu: value["cpu"],
    memory: value["memory"],
  };
}

export function serializeMachineRestartPolicy(value: MachineRestartPolicy): any {
  return value;
}

export function deserializeMachineRestartPolicy(value: any): MachineRestartPolicy {
  return value;
}

export function serializeMachineMode(value: MachineMode): any {
  // Union serialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "flash") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        if (innerKey === "strategy") {
          inner["strategy"] = serializeMachineSnapshotStrategy(innerVal as any);
          continue;
        }
        const snakeKey = innerKey.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
        inner[snakeKey] = innerVal;
      }
      result["flash"] = inner;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeMachineMode(value: any): MachineMode {
  // Union deserialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value as MachineMode;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "flash") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        if (innerKey === "strategy") {
          inner["strategy"] = deserializeMachineSnapshotStrategy(innerVal as any);
          continue;
        }
        const camelKey = innerKey.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
        inner[camelKey] = innerVal;
      }
      result["flash"] = inner;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as MachineMode;
}

export function serializeMachineSnapshotStrategy(value: MachineSnapshotStrategy): any {
  // Union serialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "nthListen") {
      result["nth-listen"] = val;
      continue;
    }
    if (key === "listenOnPort") {
      result["listen-on-port"] = val;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeMachineSnapshotStrategy(value: any): MachineSnapshotStrategy {
  // Union deserialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value as MachineSnapshotStrategy;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "nth-listen") {
      result["nthListen"] = val;
      continue;
    }
    if (key === "listen-on-port") {
      result["listenOnPort"] = val;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as MachineSnapshotStrategy;
}

export function serializeMachineVolumeBinding(value: MachineVolumeBinding): any {
  return {
    "name": value.name,
    "namespace": value.namespace,
    "path": value.path,
  };
}

export function deserializeMachineVolumeBinding(value: any): MachineVolumeBinding {
  return {
    name: value["name"],
    namespace: value["namespace"],
    path: value["path"],
  };
}

export function serializeMachineDependency(value: MachineDependency): any {
  return {
    "name": value.name,
    "namespace": value.namespace,
  };
}

export function deserializeMachineDependency(value: any): MachineDependency {
  return {
    name: value["name"],
    namespace: value["namespace"],
  };
}

export function serializeAppExpose(value: AppExpose): any {
  return {
    "port": value.port,
    "connection-tracking": value.connectionTracking !== undefined ? serializeServiceTargetConnectionTracking(value.connectionTracking) : undefined,
    "external": value.external !== undefined ? serializeAppExposeExternal(value.external) : undefined,
    "internal": value.internal !== undefined ? serializeAppExposeInternal(value.internal) : undefined,
  };
}

export function deserializeAppExpose(value: any): AppExpose {
  return {
    port: value["port"],
    connectionTracking: value["connection-tracking"] !== undefined && value["connection-tracking"] !== null ? deserializeServiceTargetConnectionTracking(value["connection-tracking"]) : undefined,
    external: value["external"] !== undefined && value["external"] !== null ? deserializeAppExposeExternal(value["external"]) : undefined,
    internal: value["internal"] !== undefined && value["internal"] !== null ? deserializeAppExposeInternal(value["internal"]) : undefined,
  };
}

export function serializeServiceTargetConnectionTracking(value: ServiceTargetConnectionTracking): any {
  // Union serialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "traffic-aware") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const snakeKey = innerKey.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
        inner[snakeKey] = innerVal;
      }
      result["traffic-aware"] = inner;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeServiceTargetConnectionTracking(value: any): ServiceTargetConnectionTracking {
  // Union deserialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value as ServiceTargetConnectionTracking;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "traffic-aware") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const camelKey = innerKey.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
        inner[camelKey] = innerVal;
      }
      result["traffic-aware"] = inner;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as ServiceTargetConnectionTracking;
}

export function serializeAppExposeExternal(value: AppExposeExternal): any {
  return {
    "host": value.host,
    "port": value.port,
    "protocol": serializeServiceBindExternalProtocol(value.protocol),
  };
}

export function deserializeAppExposeExternal(value: any): AppExposeExternal {
  return {
    host: value["host"],
    port: value["port"],
    protocol: deserializeServiceBindExternalProtocol(value["protocol"]),
  };
}

export function serializeServiceBindExternalProtocol(value: ServiceBindExternalProtocol): any {
  return value;
}

export function deserializeServiceBindExternalProtocol(value: any): ServiceBindExternalProtocol {
  return value;
}

export function serializeAppExposeInternal(value: AppExposeInternal): any {
  return {
    "port": value.port,
  };
}

export function deserializeAppExposeInternal(value: any): AppExposeInternal {
  return {
    port: value["port"],
  };
}

export function serializeAppStatus(value: AppStatus): any {
  return {
    "machine_hash": value.machineHash,
    "machine_name": value.machineName,
    "allocated_services": value.allocatedServices,
  };
}

export function deserializeAppStatus(value: any): AppStatus {
  return {
    machineHash: value["machine_hash"],
    machineName: value["machine_name"],
    allocatedServices: value["allocated_services"],
  };
}

export function serializeAppAllocatedService(value: AppAllocatedService): any {
  return {
    "name": value.name,
    "hash": value.hash,
    "domain": value.domain,
  };
}

export function deserializeAppAllocatedService(value: any): AppAllocatedService {
  return {
    name: value["name"],
    hash: value["hash"],
    domain: value["domain"],
  };
}

export function serializeApp(value: App): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "app.v1") {
      result["app.v1"] = serializeAppV1(val as any);
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeApp(value: any): App {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "app.v1") {
      result["app.v1"] = deserializeAppV1(val as any);
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as App;
}

export function serializeMe(value: Me): any {
  return {
    "tenant": value.tenant,
    "sub": value.sub,
  };
}

export function deserializeMe(value: any): Me {
  return {
    tenant: value["tenant"],
    sub: value["sub"],
  };
}

export function serializeRegistryRobot(value: RegistryRobot): any {
  return {
    "registry": value.registry,
    "user": value.user,
    "pass": value.pass,
  };
}

export function deserializeRegistryRobot(value: any): RegistryRobot {
  return {
    registry: value["registry"],
    user: value["user"],
    pass: value["pass"],
  };
}

export function serializeAllocatedBuilder(value: AllocatedBuilder): any {
  return {
    "host": value.host,
    "client_cert_pem": value.clientCertPem,
    "client_key_pem": value.clientKeyPem,
    "ca_cert_pem": value.caCertPem,
  };
}

export function deserializeAllocatedBuilder(value: any): AllocatedBuilder {
  return {
    host: value["host"],
    clientCertPem: value["client_cert_pem"],
    clientKeyPem: value["client_key_pem"],
    caCertPem: value["ca_cert_pem"],
  };
}

export function serializeGadgetInitRunParams(value: GadgetInitRunParams): any {
  return {
    "discovery_data": serializeGadgetInitDiscoveryData(value.discoveryData),
    "reasoning_effort": value.reasoningEffort !== undefined ? serializeGadgetInitReasoningEffort(value.reasoningEffort) : undefined,
    "messages": value.messages.map((x: any) => serializeGadgetClientMessage(x)),
  };
}

export function deserializeGadgetInitRunParams(value: any): GadgetInitRunParams {
  return {
    discoveryData: deserializeGadgetInitDiscoveryData(value["discovery_data"]),
    reasoningEffort: value["reasoning_effort"] !== undefined && value["reasoning_effort"] !== null ? deserializeGadgetInitReasoningEffort(value["reasoning_effort"]) : undefined,
    messages: value["messages"].map((x: any) => deserializeGadgetClientMessage(x)),
  };
}

export function serializeGadgetInitDiscoveryData(value: GadgetInitDiscoveryData): any {
  return {
    "base_dir_name": value.baseDirName,
    "base_dir_build_plan": serializeDirBuildPlan(value.baseDirBuildPlan),
  };
}

export function deserializeGadgetInitDiscoveryData(value: any): GadgetInitDiscoveryData {
  return {
    baseDirName: value["base_dir_name"],
    baseDirBuildPlan: deserializeDirBuildPlan(value["base_dir_build_plan"]),
  };
}

export function serializeDirBuildPlan(value: DirBuildPlan): any {
  return {
    "detected_providers": value.detectedProviders,
    "phases": value.phases.map((x: any) => serializeBuildPlanPhase(x)),
  };
}

export function deserializeDirBuildPlan(value: any): DirBuildPlan {
  return {
    detectedProviders: value["detected_providers"],
    phases: value["phases"].map((x: any) => deserializeBuildPlanPhase(x)),
  };
}

export function serializeBuildPlanPhase(value: BuildPlanPhase): any {
  return {
    "name": value.name,
    "build_info": value.buildInfo,
  };
}

export function deserializeBuildPlanPhase(value: any): BuildPlanPhase {
  return {
    name: value["name"],
    buildInfo: value["build_info"],
  };
}

export function serializeGadgetInitReasoningEffort(value: GadgetInitReasoningEffort): any {
  return value;
}

export function deserializeGadgetInitReasoningEffort(value: any): GadgetInitReasoningEffort {
  return value;
}

export function serializeGadgetClientMessage(value: GadgetClientMessage): any {
  return {
    "service_message": serializeGadgetServiceMessage(value.serviceMessage),
    "client_reply": value.clientReply !== undefined ? serializeGadgetClientReply(value.clientReply) : undefined,
  };
}

export function deserializeGadgetClientMessage(value: any): GadgetClientMessage {
  return {
    serviceMessage: deserializeGadgetServiceMessage(value["service_message"]),
    clientReply: value["client_reply"] !== undefined && value["client_reply"] !== null ? deserializeGadgetClientReply(value["client_reply"]) : undefined,
  };
}

export function serializeGadgetServiceMessage(value: GadgetServiceMessage): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "readfile") {
      result["ReadFile"] = serializeReadFileArgs(val as any);
      continue;
    }
    if (key === "listdir") {
      result["ListDir"] = serializeListDirArgs(val as any);
      continue;
    }
    if (key === "dirbuildplan") {
      result["DirBuildPlan"] = serializeDirBuildPlanArgs(val as any);
      continue;
    }
    if (key === "finish") {
      result["Finish"] = serializeGadgetInitData(val as any);
      continue;
    }
    if (key === "error") {
      result["Error"] = val;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeGadgetServiceMessage(value: any): GadgetServiceMessage {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "ReadFile") {
      result["readfile"] = deserializeReadFileArgs(val as any);
      continue;
    }
    if (key === "ListDir") {
      result["listdir"] = deserializeListDirArgs(val as any);
      continue;
    }
    if (key === "DirBuildPlan") {
      result["dirbuildplan"] = deserializeDirBuildPlanArgs(val as any);
      continue;
    }
    if (key === "Finish") {
      result["finish"] = deserializeGadgetInitData(val as any);
      continue;
    }
    if (key === "Error") {
      result["error"] = val;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as GadgetServiceMessage;
}

export function serializeReadFileArgs(value: ReadFileArgs): any {
  return {
    "path": value.path,
  };
}

export function deserializeReadFileArgs(value: any): ReadFileArgs {
  return {
    path: value["path"],
  };
}

export function serializeListDirArgs(value: ListDirArgs): any {
  return {
    "path": value.path,
    "max_depth": value.maxDepth,
  };
}

export function deserializeListDirArgs(value: any): ListDirArgs {
  return {
    path: value["path"],
    maxDepth: value["max_depth"],
  };
}

export function serializeDirBuildPlanArgs(value: DirBuildPlanArgs): any {
  return {
    "path": value.path,
  };
}

export function deserializeDirBuildPlanArgs(value: any): DirBuildPlanArgs {
  return {
    path: value["path"],
  };
}

export function serializeGadgetInitData(value: GadgetInitData): any {
  return {
    "plan": serializeInitPlan(value.plan),
  };
}

export function deserializeGadgetInitData(value: any): GadgetInitData {
  return {
    plan: deserializeInitPlan(value["plan"]),
  };
}

export function serializeInitPlan(value: InitPlan): any {
  return {
    "apps": value.apps.map((x: any) => serializeInitApp(x)),
    "volumes": value.volumes.map((x: any) => serializeInitVolume(x)),
    "issues": value.issues.map((x: any) => serializeInitIssue(x)),
    "warnings": value.warnings.map((x: any) => serializeInitWarning(x)),
  };
}

export function deserializeInitPlan(value: any): InitPlan {
  return {
    apps: value["apps"].map((x: any) => deserializeInitApp(x)),
    volumes: value["volumes"].map((x: any) => deserializeInitVolume(x)),
    issues: value["issues"].map((x: any) => deserializeInitIssue(x)),
    warnings: value["warnings"].map((x: any) => deserializeInitWarning(x)),
  };
}

export function serializeInitApp(value: InitApp): any {
  return {
    "name": value.name,
    "namespace": value.namespace,
    "source": serializeInitAppSource(value.source),
    "snapshot_strategy": value.snapshotStrategy !== undefined ? serializeInitAppSnapshotStrategy(value.snapshotStrategy) : undefined,
    "envs": value.envs !== undefined ? value.envs.map((x: any) => serializeInitAppEnv(x)) : undefined,
    "depends_on": value.dependsOn !== undefined ? value.dependsOn.map((x: any) => serializeInitAppDependsOn(x)) : undefined,
    "exposed_ports": value.exposedPorts !== undefined ? value.exposedPorts.map((x: any) => serializeInitAppExposedPort(x)) : undefined,
    "binded_volumes": value.bindedVolumes !== undefined ? value.bindedVolumes.map((x: any) => serializeInitAppBindedVolume(x)) : undefined,
  };
}

export function deserializeInitApp(value: any): InitApp {
  return {
    name: value["name"],
    namespace: value["namespace"],
    source: deserializeInitAppSource(value["source"]),
    snapshotStrategy: value["snapshot_strategy"] !== undefined && value["snapshot_strategy"] !== null ? deserializeInitAppSnapshotStrategy(value["snapshot_strategy"]) : undefined,
    envs: value["envs"] !== undefined && value["envs"] !== null ? value["envs"].map((x: any) => deserializeInitAppEnv(x)) : undefined,
    dependsOn: value["depends_on"] !== undefined && value["depends_on"] !== null ? value["depends_on"].map((x: any) => deserializeInitAppDependsOn(x)) : undefined,
    exposedPorts: value["exposed_ports"] !== undefined && value["exposed_ports"] !== null ? value["exposed_ports"].map((x: any) => deserializeInitAppExposedPort(x)) : undefined,
    bindedVolumes: value["binded_volumes"] !== undefined && value["binded_volumes"] !== null ? value["binded_volumes"].map((x: any) => deserializeInitAppBindedVolume(x)) : undefined,
  };
}

export function serializeInitAppSource(value: InitAppSource): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "buildautomatically") {
      result["BuildAutomatically"] = serializeInitAppBuildAuto(val as any);
      continue;
    }
    if (key === "buildwithdockerfile") {
      result["BuildWithDockerfile"] = serializeInitAppBuildDockerfile(val as any);
      continue;
    }
    if (key === "image") {
      result["Image"] = serializeInitAppImage(val as any);
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeInitAppSource(value: any): InitAppSource {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "BuildAutomatically") {
      result["buildautomatically"] = deserializeInitAppBuildAuto(val as any);
      continue;
    }
    if (key === "BuildWithDockerfile") {
      result["buildwithdockerfile"] = deserializeInitAppBuildDockerfile(val as any);
      continue;
    }
    if (key === "Image") {
      result["image"] = deserializeInitAppImage(val as any);
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as InitAppSource;
}

export function serializeInitAppBuildAuto(value: InitAppBuildAuto): any {
  return {
    "dir_path": value.dirPath,
    "append_docker_ignore_extra": value.appendDockerIgnoreExtra !== undefined ? serializeInitAppendDockerIgnoreExtra(value.appendDockerIgnoreExtra) : undefined,
  };
}

export function deserializeInitAppBuildAuto(value: any): InitAppBuildAuto {
  return {
    dirPath: value["dir_path"],
    appendDockerIgnoreExtra: value["append_docker_ignore_extra"] !== undefined && value["append_docker_ignore_extra"] !== null ? deserializeInitAppendDockerIgnoreExtra(value["append_docker_ignore_extra"]) : undefined,
  };
}

export function serializeInitAppendDockerIgnoreExtra(value: InitAppendDockerIgnoreExtra): any {
  return {
    "path": value.path,
    "lines": value.lines,
  };
}

export function deserializeInitAppendDockerIgnoreExtra(value: any): InitAppendDockerIgnoreExtra {
  return {
    path: value["path"],
    lines: value["lines"],
  };
}

export function serializeInitAppBuildDockerfile(value: InitAppBuildDockerfile): any {
  return {
    "dir_path": value.dirPath,
    "dockerfile_name": value.dockerfileName,
    "append_docker_ignore_extra": value.appendDockerIgnoreExtra !== undefined ? serializeInitAppendDockerIgnoreExtra(value.appendDockerIgnoreExtra) : undefined,
  };
}

export function deserializeInitAppBuildDockerfile(value: any): InitAppBuildDockerfile {
  return {
    dirPath: value["dir_path"],
    dockerfileName: value["dockerfile_name"],
    appendDockerIgnoreExtra: value["append_docker_ignore_extra"] !== undefined && value["append_docker_ignore_extra"] !== null ? deserializeInitAppendDockerIgnoreExtra(value["append_docker_ignore_extra"]) : undefined,
  };
}

export function serializeInitAppImage(value: InitAppImage): any {
  return {
    "image": value.image,
  };
}

export function deserializeInitAppImage(value: any): InitAppImage {
  return {
    image: value["image"],
  };
}

export function serializeInitAppSnapshotStrategy(value: InitAppSnapshotStrategy): any {
  // Union serialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "suspendafterlistenonport") {
      result["SuspendAfterListenOnPort"] = val;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeInitAppSnapshotStrategy(value: any): InitAppSnapshotStrategy {
  // Union deserialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value as InitAppSnapshotStrategy;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "SuspendAfterListenOnPort") {
      result["suspendafterlistenonport"] = val;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as InitAppSnapshotStrategy;
}

export function serializeInitAppEnv(value: InitAppEnv): any {
  return {
    "name": value.name,
    "value": serializeInitAppEnvValue(value.value),
  };
}

export function deserializeInitAppEnv(value: any): InitAppEnv {
  return {
    name: value["name"],
    value: deserializeInitAppEnvValue(value["value"]),
  };
}

export function serializeInitAppEnvValue(value: InitAppEnvValue): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "literal") {
      result["Literal"] = val;
      continue;
    }
    if (key === "expression") {
      result["Expression"] = val;
      continue;
    }
    if (key === "CopyFromEnvFile") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const snakeKey = innerKey.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
        inner[snakeKey] = innerVal;
      }
      result["CopyFromEnvFile"] = inner;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeInitAppEnvValue(value: any): InitAppEnvValue {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "Literal") {
      result["literal"] = val;
      continue;
    }
    if (key === "Expression") {
      result["expression"] = val;
      continue;
    }
    if (key === "CopyFromEnvFile") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const camelKey = innerKey.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
        inner[camelKey] = innerVal;
      }
      result["CopyFromEnvFile"] = inner;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as InitAppEnvValue;
}

export function serializeInitAppDependsOn(value: InitAppDependsOn): any {
  return {
    "name": value.name,
    "namespace": value.namespace,
  };
}

export function deserializeInitAppDependsOn(value: any): InitAppDependsOn {
  return {
    name: value["name"],
    namespace: value["namespace"],
  };
}

export function serializeInitAppExposedPort(value: InitAppExposedPort): any {
  return {
    "name": value.name,
    "port": value.port,
    "mode": serializeInitAppExposedPortMode(value.mode),
  };
}

export function deserializeInitAppExposedPort(value: any): InitAppExposedPort {
  return {
    name: value["name"],
    port: value["port"],
    mode: deserializeInitAppExposedPortMode(value["mode"]),
  };
}

export function serializeInitAppExposedPortMode(value: InitAppExposedPortMode): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "Internal") {
      result["Internal"] = serializeInitAppExposedPortProtocolInternal(val as any);
      continue;
    }
    if (key === "External") {
      result["External"] = serializeInitAppExposedPortProtocolExternal(val as any);
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeInitAppExposedPortMode(value: any): InitAppExposedPortMode {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "Internal") {
      result["Internal"] = deserializeInitAppExposedPortProtocolInternal(val as any);
      continue;
    }
    if (key === "External") {
      result["External"] = deserializeInitAppExposedPortProtocolExternal(val as any);
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as InitAppExposedPortMode;
}

export function serializeInitAppExposedPortProtocolInternal(value: InitAppExposedPortProtocolInternal): any {
  return value;
}

export function deserializeInitAppExposedPortProtocolInternal(value: any): InitAppExposedPortProtocolInternal {
  return value;
}

export function serializeInitAppExposedPortProtocolExternal(value: InitAppExposedPortProtocolExternal): any {
  return value;
}

export function deserializeInitAppExposedPortProtocolExternal(value: any): InitAppExposedPortProtocolExternal {
  return value;
}

export function serializeInitAppBindedVolume(value: InitAppBindedVolume): any {
  return {
    "name": value.name,
    "namespace": value.namespace,
    "path": value.path,
  };
}

export function deserializeInitAppBindedVolume(value: any): InitAppBindedVolume {
  return {
    name: value["name"],
    namespace: value["namespace"],
    path: value["path"],
  };
}

export function serializeInitVolume(value: InitVolume): any {
  return {
    "name": value.name,
    "namespace": value.namespace,
  };
}

export function deserializeInitVolume(value: any): InitVolume {
  return {
    name: value["name"],
    namespace: value["namespace"],
  };
}

export function serializeInitIssue(value: InitIssue): any {
  return {
    "message": value.message,
  };
}

export function deserializeInitIssue(value: any): InitIssue {
  return {
    message: value["message"],
  };
}

export function serializeInitWarning(value: InitWarning): any {
  return {
    "message": value.message,
  };
}

export function deserializeInitWarning(value: any): InitWarning {
  return {
    message: value["message"],
  };
}

export function serializeGadgetClientReply(value: GadgetClientReply): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "readfile") {
      result["ReadFile"] = serializeReadFileResult(val as any);
      continue;
    }
    if (key === "listdir") {
      result["ListDir"] = serializeListDirResult(val as any);
      continue;
    }
    if (key === "dirbuildplan") {
      result["DirBuildPlan"] = serializeDirBuildPlan(val as any);
      continue;
    }
    if (key === "error") {
      result["Error"] = val;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeGadgetClientReply(value: any): GadgetClientReply {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "ReadFile") {
      result["readfile"] = deserializeReadFileResult(val as any);
      continue;
    }
    if (key === "ListDir") {
      result["listdir"] = deserializeListDirResult(val as any);
      continue;
    }
    if (key === "DirBuildPlan") {
      result["dirbuildplan"] = deserializeDirBuildPlan(val as any);
      continue;
    }
    if (key === "Error") {
      result["error"] = val;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as GadgetClientReply;
}

export function serializeReadFileResult(value: ReadFileResult): any {
  return {
    "path": value.path,
    "content": value.content,
  };
}

export function deserializeReadFileResult(value: any): ReadFileResult {
  return {
    path: value["path"],
    content: value["content"],
  };
}

export function serializeListDirResult(value: ListDirResult): any {
  return {
    "items": value.items.map((x: any) => serializeListDirItem(x)),
  };
}

export function deserializeListDirResult(value: any): ListDirResult {
  return {
    items: value["items"].map((x: any) => deserializeListDirItem(x)),
  };
}

export function serializeListDirItem(value: ListDirItem): any {
  return {
    "path": value.path,
    "is_dir": value.isDir,
    "size": value.size,
  };
}

export function deserializeListDirItem(value: any): ListDirItem {
  return {
    path: value["path"],
    isDir: value["is_dir"],
    size: value["size"],
  };
}

export function serializeGadgetInitRunResponse(value: GadgetInitRunResponse): any {
  return {
    "messages": value.messages.map((x: any) => serializeGadgetServiceMessage(x)),
  };
}

export function deserializeGadgetInitRunResponse(value: any): GadgetInitRunResponse {
  return {
    messages: value["messages"].map((x: any) => deserializeGadgetServiceMessage(x)),
  };
}

export function serializeLogStreamParams(value: LogStreamParams): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "machine_name") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const snakeKey = innerKey.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
        inner[snakeKey] = innerVal;
      }
      result["machine_name"] = inner;
      continue;
    }
    if (key === "group_name") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const snakeKey = innerKey.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
        inner[snakeKey] = innerVal;
      }
      result["group_name"] = inner;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeLogStreamParams(value: any): LogStreamParams {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "machine_name") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const camelKey = innerKey.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
        inner[camelKey] = innerVal;
      }
      result["machine_name"] = inner;
      continue;
    }
    if (key === "group_name") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const camelKey = innerKey.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
        inner[camelKey] = innerVal;
      }
      result["group_name"] = inner;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as LogStreamParams;
}

export function serializeLogStreamItem(value: LogStreamItem): any {
  return {
    "timestamp": value.timestamp,
    "message": value.message,
    "target_stream": serializeLogStreamTarget(value.targetStream),
  };
}

export function deserializeLogStreamItem(value: any): LogStreamItem {
  return {
    timestamp: value["timestamp"],
    message: value["message"],
    targetStream: deserializeLogStreamTarget(value["target_stream"]),
  };
}

export function serializeLogStreamTarget(value: LogStreamTarget): any {
  return value;
}

export function deserializeLogStreamTarget(value: any): LogStreamTarget {
  return value;
}

export function serializeExecParams(value: ExecParams): any {
  return {
    "machine_name": value.machineName,
    "command": value.command,
    "stdin": value.stdin,
    "tty": value.tty,
  };
}

export function deserializeExecParams(value: any): ExecParams {
  return {
    machineName: value["machine_name"],
    command: value["command"],
    stdin: value["stdin"],
    tty: value["tty"],
  };
}

export function serializeMachineV1(value: MachineV1): any {
  return {
    "tags": value.tags,
    "namespace": value.namespace,
    "name": value.name,
    "image": value.image,
    "build": value.build !== undefined ? serializeMachineBuild(value.build) : undefined,
    "resources": serializeMachineResources(value.resources),
    "restart-policy": value.restartPolicy !== undefined ? serializeMachineRestartPolicy(value.restartPolicy) : undefined,
    "mode": value.mode !== undefined ? serializeMachineMode(value.mode) : undefined,
    "volumes": value.volumes !== undefined ? value.volumes.map((x: any) => serializeMachineVolumeBinding(x)) : undefined,
    "command": value.command,
    "environment": value.environment,
    "depends-on": value.dependsOn !== undefined ? value.dependsOn.map((x: any) => serializeMachineDependency(x)) : undefined,
  };
}

export function deserializeMachineV1(value: any): MachineV1 {
  return {
    tags: value["tags"],
    namespace: value["namespace"],
    name: value["name"],
    image: value["image"],
    build: value["build"] !== undefined && value["build"] !== null ? deserializeMachineBuild(value["build"]) : undefined,
    resources: deserializeMachineResources(value["resources"]),
    restartPolicy: value["restart-policy"] !== undefined && value["restart-policy"] !== null ? deserializeMachineRestartPolicy(value["restart-policy"]) : undefined,
    mode: value["mode"] !== undefined && value["mode"] !== null ? deserializeMachineMode(value["mode"]) : undefined,
    volumes: value["volumes"] !== undefined && value["volumes"] !== null ? value["volumes"].map((x: any) => deserializeMachineVolumeBinding(x)) : undefined,
    command: value["command"],
    environment: value["environment"],
    dependsOn: value["depends-on"] !== undefined && value["depends-on"] !== null ? value["depends-on"].map((x: any) => deserializeMachineDependency(x)) : undefined,
  };
}

export function serializeMachineStatus(value: MachineStatus): any {
  return {
    "hash": value.hash,
    "phase": serializeMachinePhase(value.phase),
    "image_id": value.imageId,
    "image_resolved_reference": value.imageResolvedReference,
    "machine_id": value.machineId,
    "machine_ip": value.machineIp,
    "machine_tap": value.machineTap,
    "machine_image_volume_id": value.machineImageVolumeId,
    "last_boot_time_us": value.lastBootTimeUs,
    "first_boot_time_us": value.firstBootTimeUs,
    "last_restarting_time_us": value.lastRestartingTimeUs,
    "last_exit_code": value.lastExitCode,
  };
}

export function deserializeMachineStatus(value: any): MachineStatus {
  return {
    hash: value["hash"],
    phase: deserializeMachinePhase(value["phase"]),
    imageId: value["image_id"],
    imageResolvedReference: value["image_resolved_reference"],
    machineId: value["machine_id"],
    machineIp: value["machine_ip"],
    machineTap: value["machine_tap"],
    machineImageVolumeId: value["machine_image_volume_id"],
    lastBootTimeUs: value["last_boot_time_us"],
    firstBootTimeUs: value["first_boot_time_us"],
    lastRestartingTimeUs: value["last_restarting_time_us"],
    lastExitCode: value["last_exit_code"],
  };
}

export function serializeMachinePhase(value: MachinePhase): any {
  // Union serialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "error") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const snakeKey = innerKey.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
        inner[snakeKey] = innerVal;
      }
      result["error"] = inner;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeMachinePhase(value: any): MachinePhase {
  // Union deserialization: pass through literal values
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value as MachinePhase;
  }
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "error") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const camelKey = innerKey.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
        inner[camelKey] = innerVal;
      }
      result["error"] = inner;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as MachinePhase;
}

export function serializeMachine(value: Machine): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "machine.v1") {
      result["machine.v1"] = serializeMachineV1(val as any);
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeMachine(value: any): Machine {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "machine.v1") {
      result["machine.v1"] = deserializeMachineV1(val as any);
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as Machine;
}

export function serializeServiceV1(value: ServiceV1): any {
  return {
    "tags": value.tags,
    "namespace": value.namespace,
    "name": value.name,
    "target": serializeServiceTarget(value.target),
    "bind": serializeServiceBind(value.bind),
  };
}

export function deserializeServiceV1(value: any): ServiceV1 {
  return {
    tags: value["tags"],
    namespace: value["namespace"],
    name: value["name"],
    target: deserializeServiceTarget(value["target"]),
    bind: deserializeServiceBind(value["bind"]),
  };
}

export function serializeServiceTarget(value: ServiceTarget): any {
  return {
    "name": value.name,
    "namespace": value.namespace,
    "port": value.port,
    "protocol": serializeServiceTargetProtocol(value.protocol),
    "connection-tracking": value.connectionTracking !== undefined ? serializeServiceTargetConnectionTracking(value.connectionTracking) : undefined,
  };
}

export function deserializeServiceTarget(value: any): ServiceTarget {
  return {
    name: value["name"],
    namespace: value["namespace"],
    port: value["port"],
    protocol: deserializeServiceTargetProtocol(value["protocol"]),
    connectionTracking: value["connection-tracking"] !== undefined && value["connection-tracking"] !== null ? deserializeServiceTargetConnectionTracking(value["connection-tracking"]) : undefined,
  };
}

export function serializeServiceTargetProtocol(value: ServiceTargetProtocol): any {
  return value;
}

export function deserializeServiceTargetProtocol(value: any): ServiceTargetProtocol {
  return value;
}

export function serializeServiceBind(value: ServiceBind): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "internal") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const snakeKey = innerKey.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
        inner[snakeKey] = innerVal;
      }
      result["internal"] = inner;
      continue;
    }
    if (key === "external") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        if (innerKey === "protocol") {
          inner["protocol"] = serializeServiceBindExternalProtocol(innerVal as any);
          continue;
        }
        const snakeKey = innerKey.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
        inner[snakeKey] = innerVal;
      }
      result["external"] = inner;
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeServiceBind(value: any): ServiceBind {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "internal") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        const camelKey = innerKey.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
        inner[camelKey] = innerVal;
      }
      result["internal"] = inner;
      continue;
    }
    if (key === "external") {
      const inner: any = {};
      for (const [innerKey, innerVal] of Object.entries(val as any)) {
        if (innerKey === "protocol") {
          inner["protocol"] = deserializeServiceBindExternalProtocol(innerVal as any);
          continue;
        }
        const camelKey = innerKey.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
        inner[camelKey] = innerVal;
      }
      result["external"] = inner;
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as ServiceBind;
}

export function serializeServiceStatus(value: ServiceStatus): any {
  return {
    "service_ip": value.serviceIp,
    "internal_dns_hostname": value.internalDnsHostname,
  };
}

export function deserializeServiceStatus(value: any): ServiceStatus {
  return {
    serviceIp: value["service_ip"],
    internalDnsHostname: value["internal_dns_hostname"],
  };
}

export function serializeService(value: Service): any {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "service.v1") {
      result["service.v1"] = serializeServiceV1(val as any);
      continue;
    }
    const snakeKey = key.replace(/[A-Z]/g, (m: string) => '_' + m.toLowerCase());
    result[snakeKey] = val;
  }
  return result;
}

export function deserializeService(value: any): Service {
  // Handle object variants
  const result: any = {};
  for (const [key, val] of Object.entries(value)) {
    if (key === "service.v1") {
      result["service.v1"] = deserializeServiceV1(val as any);
      continue;
    }
    const camelKey = key.replace(/_([a-z])/g, (_, m: string) => m.toUpperCase());
    result[camelKey] = val;
  }
  return result as Service;
}

export class VolumeClient {
  constructor(private baseUrl: string, private rootHeaders: Record<string, string>, private serviceHeaders: Record<string, string>, private options: RequestInit | undefined, private fetchImpl: typeof fetch, private WebSocketImpl: typeof WebSocket) {}

  private mergeHeaders(endpointHeaders: Record<string, string>): Record<string, string> {
    const optionsHeaders: Record<string, string> = {};
    if (this.options?.headers) {
      if (this.options.headers instanceof Headers) {
        this.options.headers.forEach((value, key) => { optionsHeaders[key] = value; });
      }
      else if (Array.isArray(this.options.headers)) {
        for (const [key, value] of this.options.headers) {
          optionsHeaders[key] = value;
        }
      }
      else {
        Object.assign(optionsHeaders, this.options.headers);
      }
    }
    return { ...this.rootHeaders, ...this.serviceHeaders, ...endpointHeaders, ...optionsHeaders };
  }

  async get(namespace: string, name: string): Promise<[VolumeV1, VolumeStatus]> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/volume/${name}`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return ((v: any) => [deserializeVolumeV1(v[0]), deserializeVolumeStatus(v[1])])(data);
  }

  async list(namespace?: string | undefined): Promise<[VolumeV1, VolumeStatus][]> {
    const endpointHeaders: Record<string, string> = {};
    if (namespace !== undefined) endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/volume`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return ((v: any) => v.map((x: any) => ((v: any) => [deserializeVolumeV1(v[0]), deserializeVolumeStatus(v[1])])(x)))(data);
  }

  async status(namespace: string, name: string): Promise<VolumeStatus> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/volume/${name}/status`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeVolumeStatus(data);
  }

  async delete(namespace: string, name: string): Promise<void> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/volume/${name}`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'DELETE',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

  async apply(body: Volume): Promise<void> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/volume`;
    const url = `${this.baseUrl}${path}`;
    const serializedBody = serializeVolume(body);
    const response = await this.fetchImpl(url, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...mergedHeaders },
      body: JSON.stringify(serializedBody),
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

}

export class RuntimeClient {
  constructor(private baseUrl: string, private rootHeaders: Record<string, string>, private serviceHeaders: Record<string, string>, private options: RequestInit | undefined, private fetchImpl: typeof fetch, private WebSocketImpl: typeof WebSocket) {}

  private mergeHeaders(endpointHeaders: Record<string, string>): Record<string, string> {
    const optionsHeaders: Record<string, string> = {};
    if (this.options?.headers) {
      if (this.options.headers instanceof Headers) {
        this.options.headers.forEach((value, key) => { optionsHeaders[key] = value; });
      }
      else if (Array.isArray(this.options.headers)) {
        for (const [key, value] of this.options.headers) {
          optionsHeaders[key] = value;
        }
      }
      else {
        Object.assign(optionsHeaders, this.options.headers);
      }
    }
    return { ...this.rootHeaders, ...this.serviceHeaders, ...endpointHeaders, ...optionsHeaders };
  }

  async query(body: QueryParams): Promise<QueryResponse> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/core/query`;
    const url = `${this.baseUrl}${path}`;
    const serializedBody = serializeQueryParams(body);
    const response = await this.fetchImpl(url, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...mergedHeaders },
      body: JSON.stringify(serializedBody),
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeQueryResponse(data);
  }

}

export class NamespaceClient {
  constructor(private baseUrl: string, private rootHeaders: Record<string, string>, private serviceHeaders: Record<string, string>, private options: RequestInit | undefined, private fetchImpl: typeof fetch, private WebSocketImpl: typeof WebSocket) {}

  private mergeHeaders(endpointHeaders: Record<string, string>): Record<string, string> {
    const optionsHeaders: Record<string, string> = {};
    if (this.options?.headers) {
      if (this.options.headers instanceof Headers) {
        this.options.headers.forEach((value, key) => { optionsHeaders[key] = value; });
      }
      else if (Array.isArray(this.options.headers)) {
        for (const [key, value] of this.options.headers) {
          optionsHeaders[key] = value;
        }
      }
      else {
        Object.assign(optionsHeaders, this.options.headers);
      }
    }
    return { ...this.rootHeaders, ...this.serviceHeaders, ...endpointHeaders, ...optionsHeaders };
  }

  async list(): Promise<ListNamespaces> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/core/namespaces`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeListNamespaces(data);
  }

  async delete(body: DeleteNamespaceParams): Promise<DeleteNamespaceResponse> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/core/namespaces/delete`;
    const url = `${this.baseUrl}${path}`;
    const serializedBody = serializeDeleteNamespaceParams(body);
    const response = await this.fetchImpl(url, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...mergedHeaders },
      body: JSON.stringify(serializedBody),
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeDeleteNamespaceResponse(data);
  }

}

export class CertificateClient {
  constructor(private baseUrl: string, private rootHeaders: Record<string, string>, private serviceHeaders: Record<string, string>, private options: RequestInit | undefined, private fetchImpl: typeof fetch, private WebSocketImpl: typeof WebSocket) {}

  private mergeHeaders(endpointHeaders: Record<string, string>): Record<string, string> {
    const optionsHeaders: Record<string, string> = {};
    if (this.options?.headers) {
      if (this.options.headers instanceof Headers) {
        this.options.headers.forEach((value, key) => { optionsHeaders[key] = value; });
      }
      else if (Array.isArray(this.options.headers)) {
        for (const [key, value] of this.options.headers) {
          optionsHeaders[key] = value;
        }
      }
      else {
        Object.assign(optionsHeaders, this.options.headers);
      }
    }
    return { ...this.rootHeaders, ...this.serviceHeaders, ...endpointHeaders, ...optionsHeaders };
  }

  async get(namespace: string, name: string): Promise<[CertificateV1, CertificateStatus]> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/certificate/${name}`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return ((v: any) => [deserializeCertificateV1(v[0]), deserializeCertificateStatus(v[1])])(data);
  }

  async list(namespace?: string | undefined): Promise<[CertificateV1, CertificateStatus][]> {
    const endpointHeaders: Record<string, string> = {};
    if (namespace !== undefined) endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/certificate`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return ((v: any) => v.map((x: any) => ((v: any) => [deserializeCertificateV1(v[0]), deserializeCertificateStatus(v[1])])(x)))(data);
  }

  async status(namespace: string, name: string): Promise<CertificateStatus> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/certificate/${name}/status`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeCertificateStatus(data);
  }

  async delete(namespace: string, name: string): Promise<void> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/certificate/${name}`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'DELETE',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

  async apply(body: Certificate): Promise<void> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/certificate`;
    const url = `${this.baseUrl}${path}`;
    const serializedBody = serializeCertificate(body);
    const response = await this.fetchImpl(url, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...mergedHeaders },
      body: JSON.stringify(serializedBody),
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

}

export class AppClient {
  constructor(private baseUrl: string, private rootHeaders: Record<string, string>, private serviceHeaders: Record<string, string>, private options: RequestInit | undefined, private fetchImpl: typeof fetch, private WebSocketImpl: typeof WebSocket) {}

  private mergeHeaders(endpointHeaders: Record<string, string>): Record<string, string> {
    const optionsHeaders: Record<string, string> = {};
    if (this.options?.headers) {
      if (this.options.headers instanceof Headers) {
        this.options.headers.forEach((value, key) => { optionsHeaders[key] = value; });
      }
      else if (Array.isArray(this.options.headers)) {
        for (const [key, value] of this.options.headers) {
          optionsHeaders[key] = value;
        }
      }
      else {
        Object.assign(optionsHeaders, this.options.headers);
      }
    }
    return { ...this.rootHeaders, ...this.serviceHeaders, ...endpointHeaders, ...optionsHeaders };
  }

  async get(namespace: string, name: string): Promise<[AppV1, AppStatus]> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/app/${name}`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return ((v: any) => [deserializeAppV1(v[0]), deserializeAppStatus(v[1])])(data);
  }

  async list(namespace?: string | undefined): Promise<[AppV1, AppStatus][]> {
    const endpointHeaders: Record<string, string> = {};
    if (namespace !== undefined) endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/app`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return ((v: any) => v.map((x: any) => ((v: any) => [deserializeAppV1(v[0]), deserializeAppStatus(v[1])])(x)))(data);
  }

  async status(namespace: string, name: string): Promise<AppStatus> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/app/${name}/status`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeAppStatus(data);
  }

  async delete(namespace: string, name: string): Promise<void> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/app/${name}`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'DELETE',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

  async apply(body: App): Promise<void> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/app`;
    const url = `${this.baseUrl}${path}`;
    const serializedBody = serializeApp(body);
    const response = await this.fetchImpl(url, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...mergedHeaders },
      body: JSON.stringify(serializedBody),
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

}

export class AuthClient {
  constructor(private baseUrl: string, private rootHeaders: Record<string, string>, private serviceHeaders: Record<string, string>, private options: RequestInit | undefined, private fetchImpl: typeof fetch, private WebSocketImpl: typeof WebSocket) {}

  private mergeHeaders(endpointHeaders: Record<string, string>): Record<string, string> {
    const optionsHeaders: Record<string, string> = {};
    if (this.options?.headers) {
      if (this.options.headers instanceof Headers) {
        this.options.headers.forEach((value, key) => { optionsHeaders[key] = value; });
      }
      else if (Array.isArray(this.options.headers)) {
        for (const [key, value] of this.options.headers) {
          optionsHeaders[key] = value;
        }
      }
      else {
        Object.assign(optionsHeaders, this.options.headers);
      }
    }
    return { ...this.rootHeaders, ...this.serviceHeaders, ...endpointHeaders, ...optionsHeaders };
  }

  async me(): Promise<Me> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/core/me`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeMe(data);
  }

  async registryRobotAuth(): Promise<RegistryRobot> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/core/registry/robot`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeRegistryRobot(data);
  }

  async builderRegistryRobotAuth(): Promise<RegistryRobot> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/core/registry/builder-robot`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeRegistryRobot(data);
  }

}

export class BuildClient {
  constructor(private baseUrl: string, private rootHeaders: Record<string, string>, private serviceHeaders: Record<string, string>, private options: RequestInit | undefined, private fetchImpl: typeof fetch, private WebSocketImpl: typeof WebSocket) {}

  private mergeHeaders(endpointHeaders: Record<string, string>): Record<string, string> {
    const optionsHeaders: Record<string, string> = {};
    if (this.options?.headers) {
      if (this.options.headers instanceof Headers) {
        this.options.headers.forEach((value, key) => { optionsHeaders[key] = value; });
      }
      else if (Array.isArray(this.options.headers)) {
        for (const [key, value] of this.options.headers) {
          optionsHeaders[key] = value;
        }
      }
      else {
        Object.assign(optionsHeaders, this.options.headers);
      }
    }
    return { ...this.rootHeaders, ...this.serviceHeaders, ...endpointHeaders, ...optionsHeaders };
  }

  async allocBuilder(): Promise<AllocatedBuilder> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/core/build/alloc`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'PUT',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeAllocatedBuilder(data);
  }

}

export class GadgetClient {
  constructor(private baseUrl: string, private rootHeaders: Record<string, string>, private serviceHeaders: Record<string, string>, private options: RequestInit | undefined, private fetchImpl: typeof fetch, private WebSocketImpl: typeof WebSocket) {}

  private mergeHeaders(endpointHeaders: Record<string, string>): Record<string, string> {
    const optionsHeaders: Record<string, string> = {};
    if (this.options?.headers) {
      if (this.options.headers instanceof Headers) {
        this.options.headers.forEach((value, key) => { optionsHeaders[key] = value; });
      }
      else if (Array.isArray(this.options.headers)) {
        for (const [key, value] of this.options.headers) {
          optionsHeaders[key] = value;
        }
      }
      else {
        Object.assign(optionsHeaders, this.options.headers);
      }
    }
    return { ...this.rootHeaders, ...this.serviceHeaders, ...endpointHeaders, ...optionsHeaders };
  }

  async init(body: GadgetInitRunParams): Promise<GadgetInitRunResponse> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/gadget/run/init`;
    const url = `${this.baseUrl}${path}`;
    const serializedBody = serializeGadgetInitRunParams(body);
    const response = await this.fetchImpl(url, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...mergedHeaders },
      body: JSON.stringify(serializedBody),
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeGadgetInitRunResponse(data);
  }

}

export class MachineClient {
  constructor(private baseUrl: string, private rootHeaders: Record<string, string>, private serviceHeaders: Record<string, string>, private options: RequestInit | undefined, private fetchImpl: typeof fetch, private WebSocketImpl: typeof WebSocket) {}

  private mergeHeaders(endpointHeaders: Record<string, string>): Record<string, string> {
    const optionsHeaders: Record<string, string> = {};
    if (this.options?.headers) {
      if (this.options.headers instanceof Headers) {
        this.options.headers.forEach((value, key) => { optionsHeaders[key] = value; });
      }
      else if (Array.isArray(this.options.headers)) {
        for (const [key, value] of this.options.headers) {
          optionsHeaders[key] = value;
        }
      }
      else {
        Object.assign(optionsHeaders, this.options.headers);
      }
    }
    return { ...this.rootHeaders, ...this.serviceHeaders, ...endpointHeaders, ...optionsHeaders };
  }

  logs(namespace: string, query: LogStreamParams): WebSocketStream<LogStreamItem> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/core/logs`;
    const serializedQuery = serializeLogStreamParams(query);
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(serializedQuery)) {
      if (value !== undefined && value !== null) {
        params.append(key, String(value));
      }
    }
    const url = `${this.baseUrl}${path}?${params.toString()}`;
    const stream = new WebSocketStream(url, deserializeLogStreamItem, mergedHeaders, this.WebSocketImpl);
    return stream;
  }

  exec(namespace: string, query: ExecParams): WebSocketStream<any> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/core/exec`;
    const serializedQuery = serializeExecParams(query);
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(serializedQuery)) {
      if (value !== undefined && value !== null) {
        params.append(key, String(value));
      }
    }
    const url = `${this.baseUrl}${path}?${params.toString()}`;
    const stream = new WebSocketStream(url, (data: any) => data, mergedHeaders, this.WebSocketImpl);
    return stream;
  }

  async get(namespace: string, name: string): Promise<[MachineV1, MachineStatus]> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/machine/${name}`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return ((v: any) => [deserializeMachineV1(v[0]), deserializeMachineStatus(v[1])])(data);
  }

  async list(namespace?: string | undefined): Promise<[MachineV1, MachineStatus][]> {
    const endpointHeaders: Record<string, string> = {};
    if (namespace !== undefined) endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/machine`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return ((v: any) => v.map((x: any) => ((v: any) => [deserializeMachineV1(v[0]), deserializeMachineStatus(v[1])])(x)))(data);
  }

  async status(namespace: string, name: string): Promise<MachineStatus> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/machine/${name}/status`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeMachineStatus(data);
  }

  async delete(namespace: string, name: string): Promise<void> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/machine/${name}`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'DELETE',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

  async apply(body: Machine): Promise<void> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/machine`;
    const url = `${this.baseUrl}${path}`;
    const serializedBody = serializeMachine(body);
    const response = await this.fetchImpl(url, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...mergedHeaders },
      body: JSON.stringify(serializedBody),
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

}

export class ServiceClient {
  constructor(private baseUrl: string, private rootHeaders: Record<string, string>, private serviceHeaders: Record<string, string>, private options: RequestInit | undefined, private fetchImpl: typeof fetch, private WebSocketImpl: typeof WebSocket) {}

  private mergeHeaders(endpointHeaders: Record<string, string>): Record<string, string> {
    const optionsHeaders: Record<string, string> = {};
    if (this.options?.headers) {
      if (this.options.headers instanceof Headers) {
        this.options.headers.forEach((value, key) => { optionsHeaders[key] = value; });
      }
      else if (Array.isArray(this.options.headers)) {
        for (const [key, value] of this.options.headers) {
          optionsHeaders[key] = value;
        }
      }
      else {
        Object.assign(optionsHeaders, this.options.headers);
      }
    }
    return { ...this.rootHeaders, ...this.serviceHeaders, ...endpointHeaders, ...optionsHeaders };
  }

  async get(namespace: string, name: string): Promise<[ServiceV1, ServiceStatus]> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/service/${name}`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return ((v: any) => [deserializeServiceV1(v[0]), deserializeServiceStatus(v[1])])(data);
  }

  async list(namespace?: string | undefined): Promise<[ServiceV1, ServiceStatus][]> {
    const endpointHeaders: Record<string, string> = {};
    if (namespace !== undefined) endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/service`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return ((v: any) => v.map((x: any) => ((v: any) => [deserializeServiceV1(v[0]), deserializeServiceStatus(v[1])])(x)))(data);
  }

  async status(namespace: string, name: string): Promise<ServiceStatus> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/service/${name}/status`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'GET',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  
    const data = await response.json();
    return deserializeServiceStatus(data);
  }

  async delete(namespace: string, name: string): Promise<void> {
    const endpointHeaders: Record<string, string> = {};
    endpointHeaders['x-ignition-namespace'] = String(namespace);
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/service/${name}`;
    const url = `${this.baseUrl}${path}`;
    const response = await this.fetchImpl(url, {
      method: 'DELETE',
      headers: mergedHeaders,
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

  async apply(body: Service): Promise<void> {
    const endpointHeaders: Record<string, string> = {};
    const mergedHeaders = this.mergeHeaders(endpointHeaders);
  
    const path = `/service`;
    const url = `${this.baseUrl}${path}`;
    const serializedBody = serializeService(body);
    const response = await this.fetchImpl(url, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...mergedHeaders },
      body: JSON.stringify(serializedBody),
      ...this.options,
    });
  
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

}

export interface ClientConfig {
  baseUrl: string;
  apiToken: string;
  options?: RequestInit;
  fetchImpl?: typeof fetch;
  WebSocketImpl?: typeof WebSocket;
}

export class Client {
  private readonly baseUrl: string;
  private readonly rootHeader_apiToken: any;
  private readonly options?: RequestInit;
  private readonly fetchImpl: typeof fetch;
  private readonly WebSocketImpl: typeof WebSocket;

  constructor(config: ClientConfig) {
    this.baseUrl = config.baseUrl;
    this.rootHeader_apiToken = config.apiToken;
    this.options = config.options;
    this.fetchImpl = config.fetchImpl || globalThis.fetch;
    this.WebSocketImpl = config.WebSocketImpl || globalThis.WebSocket;
  }

  get volume(): VolumeClient {
    const rootHeaders: Record<string, string> = {};
    rootHeaders['x-ignition-compat'] = '1';
    rootHeaders['x-ignition-token'] = String(this.rootHeader_apiToken);
    const serviceHeaders: Record<string, string> = {};
    return new VolumeClient(this.baseUrl, rootHeaders, serviceHeaders, this.options, this.fetchImpl, this.WebSocketImpl);
  }

  get runtime(): RuntimeClient {
    const rootHeaders: Record<string, string> = {};
    rootHeaders['x-ignition-compat'] = '1';
    rootHeaders['x-ignition-token'] = String(this.rootHeader_apiToken);
    const serviceHeaders: Record<string, string> = {};
    return new RuntimeClient(this.baseUrl, rootHeaders, serviceHeaders, this.options, this.fetchImpl, this.WebSocketImpl);
  }

  get namespace(): NamespaceClient {
    const rootHeaders: Record<string, string> = {};
    rootHeaders['x-ignition-compat'] = '1';
    rootHeaders['x-ignition-token'] = String(this.rootHeader_apiToken);
    const serviceHeaders: Record<string, string> = {};
    return new NamespaceClient(this.baseUrl, rootHeaders, serviceHeaders, this.options, this.fetchImpl, this.WebSocketImpl);
  }

  get certificate(): CertificateClient {
    const rootHeaders: Record<string, string> = {};
    rootHeaders['x-ignition-compat'] = '1';
    rootHeaders['x-ignition-token'] = String(this.rootHeader_apiToken);
    const serviceHeaders: Record<string, string> = {};
    return new CertificateClient(this.baseUrl, rootHeaders, serviceHeaders, this.options, this.fetchImpl, this.WebSocketImpl);
  }

  get app(): AppClient {
    const rootHeaders: Record<string, string> = {};
    rootHeaders['x-ignition-compat'] = '1';
    rootHeaders['x-ignition-token'] = String(this.rootHeader_apiToken);
    const serviceHeaders: Record<string, string> = {};
    return new AppClient(this.baseUrl, rootHeaders, serviceHeaders, this.options, this.fetchImpl, this.WebSocketImpl);
  }

  get auth(): AuthClient {
    const rootHeaders: Record<string, string> = {};
    rootHeaders['x-ignition-compat'] = '1';
    rootHeaders['x-ignition-token'] = String(this.rootHeader_apiToken);
    const serviceHeaders: Record<string, string> = {};
    return new AuthClient(this.baseUrl, rootHeaders, serviceHeaders, this.options, this.fetchImpl, this.WebSocketImpl);
  }

  get build(): BuildClient {
    const rootHeaders: Record<string, string> = {};
    rootHeaders['x-ignition-compat'] = '1';
    rootHeaders['x-ignition-token'] = String(this.rootHeader_apiToken);
    const serviceHeaders: Record<string, string> = {};
    return new BuildClient(this.baseUrl, rootHeaders, serviceHeaders, this.options, this.fetchImpl, this.WebSocketImpl);
  }

  get gadget(): GadgetClient {
    const rootHeaders: Record<string, string> = {};
    rootHeaders['x-ignition-compat'] = '1';
    rootHeaders['x-ignition-token'] = String(this.rootHeader_apiToken);
    const serviceHeaders: Record<string, string> = {};
    return new GadgetClient(this.baseUrl, rootHeaders, serviceHeaders, this.options, this.fetchImpl, this.WebSocketImpl);
  }

  get machine(): MachineClient {
    const rootHeaders: Record<string, string> = {};
    rootHeaders['x-ignition-compat'] = '1';
    rootHeaders['x-ignition-token'] = String(this.rootHeader_apiToken);
    const serviceHeaders: Record<string, string> = {};
    return new MachineClient(this.baseUrl, rootHeaders, serviceHeaders, this.options, this.fetchImpl, this.WebSocketImpl);
  }

  get service(): ServiceClient {
    const rootHeaders: Record<string, string> = {};
    rootHeaders['x-ignition-compat'] = '1';
    rootHeaders['x-ignition-token'] = String(this.rootHeader_apiToken);
    const serviceHeaders: Record<string, string> = {};
    return new ServiceClient(this.baseUrl, rootHeaders, serviceHeaders, this.options, this.fetchImpl, this.WebSocketImpl);
  }

}

